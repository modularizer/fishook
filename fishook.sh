#!/usr/bin/env bash
# fishook.sh
#
# fishook = tiny git hook runner driven by a JSON file.
#
# Usage:
#   $0 install                     [--config /path/to/fishook.json] [--hooks-path PATH]     # install all hooks
#   $0 uninstall                   [--hooks-path PATH]                                      # uninstall all hooks
#   $0 list                                                                                 # lists all hooks
#   $0 explain <hook-name>         [--config /path/to/fishook.json] [--hooks-path PATH]     # explain hook + show configured actions
#   $0 <hook-name>  [hook-args...] [--config /path/to/fishook.json] [--dry-run]             # run the hook
#
# fishook.json:
#   - Put a fishook.json in your repo (default: <repo-root>/fishook.json)
#   - Keys are git hook names (e.g. "pre-commit", "commit-msg")
#   - Values are:
#       * "string command"
#       * ["cmd1", "cmd2", ...]
#       * {"run": "cmd"} or {"run": ["cmd1","cmd2"]}  ("commands" also works)
#       * object with optional event handlers + optional filters:
#           {
#             "run": ["echo runs once"],
#             "onAdd": ["..."], "onChange": ["..."], "onDelete": ["..."],
#             "onMove": ["..."], "onCopy": ["..."],
#             "onFileEvent": ["..."],
#             "onRefCreate": ["..."], "onRefUpdate": ["..."], "onRefDelete": ["..."],
#             "onRefEvent": ["..."],
#             "onEvent": ["..."],
#             "applyTo": ["glob", ...],   # file-event filter (defaults to all)
#             "skipList": ["glob", ...]   # file-event filter (defaults to none)
#           }
#       * OR an array of such objects ("blocks"):
#           [
#             { "applyTo": ["*.js"], "onAdd": ["..."] },
#             { "applyTo": ["*.ts"], "onAdd": ["..."] }
#           ]
#
# Notes on filters:
#   - applyTo/skipList are evaluated per file event using the "primary" path:
#       add/change/delete -> FISHOOK_PATH
#       move/copy         -> FISHOOK_DST (preferred), else FISHOOK_PATH, else FISHOOK_SRC
#   - For ref events, applyTo/skipList are ignored (for now).

set -euo pipefail

# ---- hooks list (all standard git hooks) ----
ALL_HOOKS=(
  applypatch-msg pre-applypatch post-applypatch
  pre-commit pre-merge-commit prepare-commit-msg commit-msg post-commit
  pre-rebase post-checkout post-merge post-rewrite
  pre-push pre-auto-gc
  pre-receive update post-receive post-update push-to-checkout proc-receive
  sendemail-validate fsmonitor-watchman
)

# ---- globals set by flag parsing ----
CONFIG_PATH=""
HOOKS_PATH=""
DRY_RUN=0

# Enable richer globs in [[ "$p" == $glob ]] matching (extglob helps; ** works fine as * * in pattern matching)
shopt -s extglob

# ---- helpers ----
die() { echo "fishook: $*" >&2; exit 2; }

in_git_repo() { git rev-parse --is-inside-work-tree >/dev/null 2>&1; }
repo_root() { git rev-parse --show-toplevel 2>/dev/null; }
git_dir() { git rev-parse --git-dir 2>/dev/null; }

default_config_path() {
  local root
  root="$(repo_root)" || die "not inside a git repository"
  echo "${root}/fishook.json"
}

default_hooks_path() {
  local gd
  gd="$(git_dir)" || die "not inside a git repository"
  echo "${gd}/hooks"
}

timestamp() { date +"%Y%m%d-%H%M%S"; }

require_jq() { command -v jq >/dev/null 2>&1 || die "requires 'jq'"; }

# Parse flags anywhere in argv and return remaining positional args as NUL-delimited.
# Supports: --config, --hooks-path, --dry-run (plus = forms)
parse_flags() {
  local -a out=()
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --config)
        [[ $# -ge 2 ]] || die "--config requires a path"
        CONFIG_PATH="$2"; shift 2 ;;
      --config=*)
        CONFIG_PATH="${1#*=}"; shift ;;
      --hooks-path)
        [[ $# -ge 2 ]] || die "--hooks-path requires a path"
        HOOKS_PATH="$2"; shift 2 ;;
      --hooks-path=*)
        HOOKS_PATH="${1#*=}"; shift ;;
      --dry-run)
        DRY_RUN=1; shift ;;
      --)
        shift
        while [[ $# -gt 0 ]]; do out+=("$1"); shift; done
        ;;
      -*)
        die "unknown option: $1"
        ;;
      *)
        out+=("$1"); shift ;;
    esac
  done
  printf '%s\0' "${out[@]}"
}

hook_known() {
  local h="$1" x
  for x in "${ALL_HOOKS[@]}"; do
    [[ "$x" == "$h" ]] && return 0
  done
  return 1
}

# Detect whether a hook file is fishook-managed.
is_fishook_stub() {
  local file="$1"
  [[ -f "$file" ]] || return 1
  grep -qE '^# fishook-managed stub' "$file"
}

# Write a stub that calls fishook.sh <hook>, from repo root.
write_stub() {
  local hook="$1"
  local target="$2"
  cat >"$target" <<EOF
#!/usr/bin/env bash
set -euo pipefail

# fishook-managed stub for ${hook}
# This file is generated by: ./fishook.sh install

REPO_ROOT="\$(git rev-parse --show-toplevel 2>/dev/null)"
if [[ -z "\${REPO_ROOT}" ]]; then
  echo "fishook: cannot find repo root" >&2
  exit 2
fi

exec "\${REPO_ROOT}/fishook.sh" ${hook} "\$@"
EOF
  chmod +x "$target"
}

# For chained hooks, create a stub that runs prev first then fishook.
write_chained_stub() {
  local hook="$1"
  local target="$2"
  local prev="$3"
  cat >"$target" <<EOF
#!/usr/bin/env bash
set -euo pipefail

# fishook-managed stub for ${hook} (chained)
# previous hook preserved at: ${prev}

if [[ -x "${prev}" ]]; then
  "${prev}" "\$@"
fi

REPO_ROOT="\$(git rev-parse --show-toplevel 2>/dev/null)"
if [[ -z "\${REPO_ROOT}" ]]; then
  echo "fishook: cannot find repo root" >&2
  exit 2
fi

exec "\${REPO_ROOT}/fishook.sh" ${hook} "\$@"
EOF
  chmod +x "$target"
}

prompt_choice() {
  local hook="$1"
  local file="$2"
  echo
  echo "fishook: found existing hook: ${file}"
  echo "hook: ${hook}"
  echo
  echo "Choose what to do:"
  echo "  1) overwrite (replace existing hook with fishook)"
  echo "  2) chain (rename existing to ${file}.fishook-prev and run it before fishook)"
  echo "  3) backup (rename existing to ${file}.bak.<timestamp>; not chained)"
  echo -n "Enter 1/2/3: " >&2
  read -r choice
  echo "$choice"
}

# Full sample config (small). Written only if missing.
write_sample_config() {
  local path="$1"
  local dir
  dir="$(dirname "$path")"
  mkdir -p "$dir"

  if [[ -e "$path" ]]; then
    echo "fishook: config already exists, leaving it alone: ${path}" >&2
    return 0
  fi

  cat >"$path" <<'EOF'
{
  "_about": "run `fishook list` to see all options",
  "pre-commit": {
      "onFileEvent": "new | grep -qi turtles && raise \"contains forbidden word 'turtles'\"",
      "skipList": ["fishook.json", "fishook.sh"]
  }
}
EOF

  echo "fishook: wrote sample config: ${path}" >&2
}

# ---- JSON helpers ----
# Normalize a JSON value into an array of strings.
# - null/missing -> []
# - string       -> [string]
# - array        -> array
# - object       -> (.run // .commands) normalized similarly (legacy)
normalize_to_cmd_array() {
  jq -c '
    def normalize:
      if . == null then []
      elif type=="string" then [.]
      elif type=="array" then .
      elif type=="object" then (.run // .commands) | normalize
      else error("invalid command value")
      end;
    normalize
  '
}

# Get the raw JSON value for a hook (or empty).
hook_entry_json() {
  local hook="$1"
  jq -c --arg h "$hook" '(.[$h] // empty)' "$CONFIG_PATH"
}

# Does hook entry have "blocks" (object or array-of-objects)?
hook_entry_has_blocks() {
  local hook="$1"
  local entry_type
  entry_type=$(jq -r --arg h "$hook" 'if .[$h] then (.[$h] | type) else "null" end' "$CONFIG_PATH")
  [[ "$entry_type" == "object" || "$entry_type" == "array" ]]
}

# Return a JSON array of "blocks" for a hook:
# - object -> [object]
# - array  -> array
# - else   -> []
hook_blocks_json() {
  local hook="$1"
  jq -c --arg h "$hook" '
    (.[$h] // null) as $e
    | if $e == null then []
      elif ($e|type) == "object" then [$e]
      elif ($e|type) == "array" then $e
      else []
      end
  ' "$CONFIG_PATH"
}

# For legacy/simple "run" support:
# - string/array -> those commands
# - object       -> .run/.commands
# - array        -> concatenate each block's .run/.commands (if present)
hook_run_cmds_json() {
  local hook="$1"
  jq -c --arg h "$hook" '
    def normalize:
      if . == null then []
      elif type=="string" then [.]
      elif type=="array" then .
      elif type=="object" then (.run // .commands) | normalize
      else []
      end;

    (.[$h] // null) as $e
    | if $e == null then []
      elif ($e|type) == "string" then $e | normalize
      elif ($e|type) == "object" then ($e.run // $e.commands) | normalize
      elif ($e|type) == "array" then
        if ($e | length) > 0 and ($e[0] | type) == "object" then
          ( $e | map((.run // .commands) | normalize) | add ) // []
        else
          $e | normalize
        end
      else []
      end
  ' "$CONFIG_PATH"
}

# Extract a key's commands from a single block JSON (object), normalized to JSON array.
block_key_cmds_json() {
  local block_json="$1"
  local key="$2"
  printf '%s' "$block_json" | jq -c --arg k "$key" '
    def normalize:
      if . == null then []
      elif type=="string" then [.]
      elif type=="array" then .
      elif type=="object" then (.run // .commands) | normalize
      else error("invalid command value")
      end;
    (.[ $k ] // null) | normalize
  '
}

# Extract applyTo / skipList from a block, as JSON arrays of strings (possibly empty).
block_apply_to_json() {
  local block_json="$1"
  printf '%s' "$block_json" | jq -c '
    def norm:
      if . == null then []
      elif type=="string" then [.]
      elif type=="array" then .
      else error("applyTo must be string or array")
      end;
    (.applyTo // null) | norm
  '
}

block_skip_list_json() {
  local block_json="$1"
  printf '%s' "$block_json" | jq -c '
    def norm:
      if . == null then []
      elif type=="string" then [.]
      elif type=="array" then .
      else error("skipList must be string or array")
      end;
    (.skipList // null) | norm
  '
}

# Extract top-level "setup" and "source" commands (run before every command).
config_setup_cmds() {
  local setup source_cmd result
  setup=$(jq -r 'if .setup == null then "" elif (.setup | type) == "string" then .setup elif (.setup | type) == "array" then (.setup | join("; ")) else "" end' "$CONFIG_PATH")
  source_cmd=$(jq -r 'if .source == null then "" elif (.source | type) == "string" then "source " + .source elif (.source | type) == "array" then (.source | map("source " + .) | join("; ")) else "" end' "$CONFIG_PATH")

  result=""
  [[ -n "$setup" ]] && result="$setup"
  [[ -n "$source_cmd" ]] && result="${result:+$result; }$source_cmd"
  printf '%s' "$result"
}

# ---- hook explanations (short, useful defaults) ----
hook_explain_text() {
  local h="$1"
  case "$h" in
    applypatch-msg) echo "Runs during git am after extracting a patch commit message; validate/edit the message." ;;
    pre-applypatch) echo "Runs during git am before committing the applied patch; can reject." ;;
    post-applypatch) echo "Runs during git am after committing; notification only." ;;
    pre-commit) echo "Runs before a commit is created; commonly lint/tests/format checks; can reject." ;;
    pre-merge-commit) echo "Runs before creating a merge commit (when merge is clean); can reject." ;;
    prepare-commit-msg) echo "Runs before commit message editor opens; can prefill/edit message." ;;
    commit-msg) echo "Runs after message is written; validate commit message; can reject." ;;
    post-commit) echo "Runs after commit is created; notification only." ;;
    pre-rebase) echo "Runs before rebase starts; can reject." ;;
    post-checkout) echo "Runs after checkout/switch; args old/new/flag." ;;
    post-merge) echo "Runs after merge; arg is squash flag." ;;
    post-rewrite) echo "Runs after commit rewriting; arg is rewrite command; stdin has old/new oids." ;;
    pre-push) echo "Runs before pushing; args remote_name/remote_url; stdin lists ref updates." ;;
    pre-auto-gc) echo "Runs before git gc --auto; can abort." ;;
    pre-receive) echo "Server-side: before accepting pushed refs; stdin old/new/ref triples. Not run on GitHub." ;;
    update) echo "Server-side: per-ref update check; args ref/old/new. Not run on GitHub." ;;
    post-receive) echo "Server-side: after refs updated; stdin old/new/ref triples. Not run on GitHub." ;;
    post-update) echo "Server-side: after refs updated; args are ref names. Not run on GitHub." ;;
    push-to-checkout) echo "Server-side: when pushing to checked-out branch with updateInstead. Not run on GitHub." ;;
    proc-receive) echo "Server-side: advanced receive-pack protocol hook. Not run on GitHub." ;;
    sendemail-validate) echo "Runs during git send-email to validate outgoing patch email; can reject." ;;
    fsmonitor-watchman) echo "Used by core.fsmonitor to speed status; reports changed files." ;;
    *) echo "Unknown hook (or not in fishook's known list)." ;;
  esac
}

# ---- env vars ----
export_base_env() {
  local hook="$1"
  local root gd
  root="$(repo_root)" || root=""
  gd="$(git_dir)" || gd=""

  export FISHOOK_HOOK="$hook"
  export FISHOOK_REPO_ROOT="$root"
  export FISHOOK_REPO_NAME="$(basename "$root" 2>/dev/null || echo "")"
  export FISHOOK_GIT_DIR="$gd"
  export FISHOOK_CONFIG_PATH="$CONFIG_PATH"
  export FISHOOK_HOOKS_PATH="$HOOKS_PATH"
  export FISHOOK_DRY_RUN="$DRY_RUN"
  export FISHOOK_CWD="$(pwd)"
  export FISHOOK_ARGV0="$0"
}

clear_event_env() {
  unset FISHOOK_EVENT_KIND FISHOOK_EVENT FISHOOK_STATUS
  unset FISHOOK_PATH FISHOOK_ABS_PATH
  unset FISHOOK_SRC FISHOOK_DST FISHOOK_ABS_SRC FISHOOK_ABS_DST
  unset FISHOOK_REF
  # NOTE: We intentionally DO NOT unset FISHOOK_OLD_OID / FISHOOK_NEW_OID here
  # because for some hooks we want those to be stable across emitted file events.
  unset FISHOOK_REMOTE_NAME FISHOOK_REMOTE_URL
}

abs_in_repo() {
  local rel="$1"
  [[ -z "${FISHOOK_REPO_ROOT:-}" ]] && echo "$rel" && return 0
  echo "${FISHOOK_REPO_ROOT%/}/${rel}"
}

# ---- glob filtering (block-level applyTo/skipList) ----
fishook_primary_path() {
  # For move/copy, prefer DST; otherwise PATH; otherwise SRC.
  if [[ -n "${FISHOOK_DST:-}" ]]; then
    printf '%s\n' "$FISHOOK_DST"
  elif [[ -n "${FISHOOK_PATH:-}" ]]; then
    printf '%s\n' "$FISHOOK_PATH"
  else
    printf '%s\n' "${FISHOOK_SRC:-}"
  fi
}

fishook_any_match() {
  local s="$1"; shift || true
  local g
  for g in "$@"; do
    [[ -z "$g" ]] && continue
    [[ "$s" == $g ]] && return 0
  done
  return 1
}

fishook_block_allows_path() {
  local p="$1"; shift || true
  local -a apply=() skip=()
  local mode="apply"
  while [[ $# -gt 0 ]]; do
    if [[ "$1" == "--" ]]; then mode="skip"; shift; continue; fi
    if [[ "$mode" == "apply" ]]; then apply+=("$1"); else skip+=("$1"); fi
    shift
  done

  if [[ "${#apply[@]}" -gt 0 ]]; then
    fishook_any_match "$p" "${apply[@]}" || return 1
  fi
  if [[ "${#skip[@]}" -gt 0 ]]; then
    fishook_any_match "$p" "${skip[@]}" && return 1
  fi
  return 0
}

# ---- execution helpers ----
run_one_cmd() {
  local hook="$1"
  local cmd="$2"
  shift 2 || true
  local -a hook_args=("$@")

  [[ "$DRY_RUN" -eq 1 ]] && return 0

  # Setup/source commands (run before everything)
  local setup_cmds
  setup_cmds="$(config_setup_cmds)"
  [[ -n "$setup_cmds" ]] && setup_cmds="${setup_cmds}; "

  # Helper funcs injected into the bash -lc scope (no temp files).
  local scope
  scope=$'\
fishook_old_path(){ printf "%s\\n" "${FISHOOK_SRC:-${FISHOOK_PATH:-}}"; }\n\
fishook_new_path(){ printf "%s\\n" "${FISHOOK_DST:-${FISHOOK_PATH:-}}"; }\n\
old(){\n\
  local p; p="$(fishook_old_path)"; [[ -z "$p" ]] && return 0\n\
  if [[ -n "${FISHOOK_OLD_OID:-}" ]]; then git show "${FISHOOK_OLD_OID}:$p" 2>/dev/null || true\n\
  else git show "HEAD:$p" 2>/dev/null || true\n\
  fi\n\
}\n\
new(){\n\
  local p; p="$(fishook_new_path)"; [[ -z "$p" ]] && return 0\n\
  if [[ -n "${FISHOOK_NEW_OID:-}" ]]; then git show "${FISHOOK_NEW_OID}:$p" 2>/dev/null || true\n\
  else git show ":$p" 2>/dev/null || cat -- "$p" 2>/dev/null || true\n\
  fi\n\
}\n\
diff(){\n\
  local p_old p_new p\n\
  p_old="$(fishook_old_path)"; p_new="$(fishook_new_path)"; p="${p_new:-$p_old}"\n\
  [[ -z "$p" ]] && return 0\n\
  if [[ -n "${FISHOOK_OLD_OID:-}" && -n "${FISHOOK_NEW_OID:-}" ]]; then\n\
    git diff --no-color --text "${FISHOOK_OLD_OID}" "${FISHOOK_NEW_OID}" -- "$p" 2>/dev/null || true\n\
  else\n\
    git diff --cached --no-color --text -- "$p" 2>/dev/null || true\n\
  fi\n\
}\n\
raise(){\n\
  echo "âŒ ${FISHOOK_HOOK:-hook} failed on ${FISHOOK_PATH:-${FISHOOK_DST:-${FISHOOK_SRC:-?}}}: $1" >&2\n\
  exit 1\n\
}\n\
'

  # Only pass args if non-empty (avoid quoting issues)
  local args_quoted=""
  if [[ "${#hook_args[@]}" -gt 0 && -n "${hook_args[0]}" ]]; then
    args_quoted="$(printf '%q ' "${hook_args[@]}" | sed 's/ $//')"
  fi

  if [[ -n "$args_quoted" ]]; then
    bash -c "${setup_cmds}${scope}${cmd} ${args_quoted}"
  else
    bash -c "${setup_cmds}${scope}${cmd}"
  fi
}

# ---- event dispatch (block-aware) ----
dispatch_event_handlers() {
  local hook="$1"
  shift || true
  local -a hook_args=("$@")

  local specific="" kind_generic="" universal="onEvent"

  if [[ "${FISHOOK_EVENT_KIND:-}" == "file" ]]; then
    kind_generic="onFileEvent"
    case "${FISHOOK_EVENT:-}" in
      add) specific="onAdd" ;;
      change) specific="onChange" ;;
      delete) specific="onDelete" ;;
      move) specific="onMove" ;;
      copy) specific="onCopy" ;;
    esac
  elif [[ "${FISHOOK_EVENT_KIND:-}" == "ref" ]]; then
    kind_generic="onRefEvent"
    case "${FISHOOK_EVENT:-}" in
      ref_create) specific="onRefCreate" ;;
      ref_update) specific="onRefUpdate" ;;
      ref_delete) specific="onRefDelete" ;;
    esac
  fi

  local blocks_json block
  blocks_json="$(hook_blocks_json "$hook")"
  [[ "$blocks_json" == "[]" ]] && return 0

  # Iterate blocks
  while IFS= read -r block; do
    # Apply file filters if applicable
    if [[ "${FISHOOK_EVENT_KIND:-}" == "file" ]]; then
      local p
      p="$(fishook_primary_path)"
      local apply_json skip_json
      apply_json="$(block_apply_to_json "$block")"
      skip_json="$(block_skip_list_json "$block")"

      local -a apply=() skip=()
      mapfile -t apply < <(printf '%s' "$apply_json" | jq -r '.[]')
      mapfile -t skip  < <(printf '%s' "$skip_json"  | jq -r '.[]')

      if ! fishook_block_allows_path "$p" "${apply[@]}" -- "${skip[@]}"; then
        continue
      fi
    fi

    # Run handlers in order: specific -> kind_generic -> universal
    local key cmds_json cmd
    for key in "$specific" "$kind_generic" "$universal"; do
      [[ -z "$key" ]] && continue
      cmds_json="$(block_key_cmds_json "$block" "$key")"
      [[ "$cmds_json" == "[]" ]] && continue
      while IFS= read -r cmd; do
        run_one_cmd "$hook" "$cmd" "${hook_args[@]}"
      done < <(printf '%s' "$cmds_json" | jq -r '.[]')
    done
  done < <(printf '%s' "$blocks_json" | jq -c '.[]') # stable line-per-block
}

# ---- event emitters ----
emit_file_events_from_name_status_z() {
  local hook="$1"
  local old_oid="${2:-}"
  local new_oid="${3:-}"
  shift 3 || true
  local -a hook_args=("$@")

  # input is: status\0path\0  OR  Rxxx\0src\0dst\0, Cxxx\0src\0dst\0
  while IFS= read -r -d '' status; do
    case "$status" in
      A|M|D)
        IFS= read -r -d '' path || true
        clear_event_env
        export FISHOOK_EVENT_KIND="file"
        export FISHOOK_STATUS="$status"
        export FISHOOK_PATH="$path"
        export FISHOOK_ABS_PATH="$(abs_in_repo "$path")"
        [[ -n "$old_oid" ]] && export FISHOOK_OLD_OID="$old_oid" || true
        [[ -n "$new_oid" ]] && export FISHOOK_NEW_OID="$new_oid" || true
        case "$status" in
          A) export FISHOOK_EVENT="add" ;;
          M) export FISHOOK_EVENT="change" ;;
          D) export FISHOOK_EVENT="delete" ;;
        esac
        dispatch_event_handlers "$hook" "${hook_args[@]}"
        ;;
      R*|C*)
        IFS= read -r -d '' src || true
        IFS= read -r -d '' dst || true
        clear_event_env
        export FISHOOK_EVENT_KIND="file"
        export FISHOOK_STATUS="$status"
        export FISHOOK_SRC="$src"
        export FISHOOK_DST="$dst"
        export FISHOOK_ABS_SRC="$(abs_in_repo "$src")"
        export FISHOOK_ABS_DST="$(abs_in_repo "$dst")"
        [[ -n "$old_oid" ]] && export FISHOOK_OLD_OID="$old_oid" || true
        [[ -n "$new_oid" ]] && export FISHOOK_NEW_OID="$new_oid" || true
        case "$status" in
          R*) export FISHOOK_EVENT="move" ;;
          C*) export FISHOOK_EVENT="copy" ;;
        esac
        dispatch_event_handlers "$hook" "${hook_args[@]}"
        ;;
      *)
        :
        ;;
    esac
  done
}

emit_pre_commit_file_events() {
  local hook="$1"; shift || true
  local -a hook_args=("$@")
  # old/new unset => diff() falls back to --cached
  git diff --cached --name-status -z | emit_file_events_from_name_status_z "$hook" "" "" "${hook_args[@]}"
}

emit_diff_tree_file_events() {
  local hook="$1"
  local old="$2"
  local new="$3"
  shift 3 || true
  local -a hook_args=("$@")

  git cat-file -e "${old}^{commit}" >/dev/null 2>&1 || return 0
  git cat-file -e "${new}^{commit}" >/dev/null 2>&1 || return 0

  git diff-tree -r --name-status -z "$old" "$new" | emit_file_events_from_name_status_z "$hook" "$old" "$new" "${hook_args[@]}"
}

emit_post_checkout_file_events() {
  local hook="$1"; shift || true
  local -a hook_args=("$@")
  local old="${hook_args[0]:-}"
  local new="${hook_args[1]:-}"
  [[ -n "$old" && -n "$new" ]] || return 0
  emit_diff_tree_file_events "$hook" "$old" "$new" "${hook_args[@]}"
}

emit_post_merge_file_events() {
  local hook="$1"; shift || true
  local -a hook_args=("$@")
  local old new
  old="$(git rev-parse -q --verify ORIG_HEAD 2>/dev/null || true)"
  new="$(git rev-parse -q --verify HEAD 2>/dev/null || true)"
  [[ -n "$old" && -n "$new" ]] || return 0
  emit_diff_tree_file_events "$hook" "$old" "$new" "${hook_args[@]}"
}

emit_ref_events_pre_push() {
  local hook="$1"; shift || true
  local -a hook_args=("$@")
  local remote_name="${hook_args[0]:-}"
  local remote_url="${hook_args[1]:-}"

  while read -r local_ref local_oid remote_ref remote_oid; do
    [[ -z "${local_ref:-}" ]] && continue
    clear_event_env
    export FISHOOK_EVENT_KIND="ref"
    export FISHOOK_REMOTE_NAME="$remote_name"
    export FISHOOK_REMOTE_URL="$remote_url"
    export FISHOOK_REF="$remote_ref"
    export FISHOOK_OLD_OID="$remote_oid"
    export FISHOOK_NEW_OID="$local_oid"

    if [[ "${remote_oid:-}" =~ ^0+$ ]]; then
      export FISHOOK_EVENT="ref_create"
    elif [[ "${local_oid:-}" =~ ^0+$ ]]; then
      export FISHOOK_EVENT="ref_delete"
    else
      export FISHOOK_EVENT="ref_update"
    fi

    dispatch_event_handlers "$hook" "${hook_args[@]}"
  done
}

emit_ref_events_receive_pack_stdin() {
  local hook="$1"; shift || true
  local -a hook_args=("$@")
  while read -r old_oid new_oid ref; do
    [[ -z "${ref:-}" ]] && continue
    clear_event_env
    export FISHOOK_EVENT_KIND="ref"
    export FISHOOK_REF="$ref"
    export FISHOOK_OLD_OID="$old_oid"
    export FISHOOK_NEW_OID="$new_oid"

    if [[ "${old_oid:-}" =~ ^0+$ ]]; then
      export FISHOOK_EVENT="ref_create"
    elif [[ "${new_oid:-}" =~ ^0+$ ]]; then
      export FISHOOK_EVENT="ref_delete"
    else
      export FISHOOK_EVENT="ref_update"
    fi

    dispatch_event_handlers "$hook" "${hook_args[@]}"
  done
}

emit_ref_event_update_args() {
  local hook="$1"; shift || true
  local -a hook_args=("$@")
  local ref="${hook_args[0]:-}"
  local old_oid="${hook_args[1]:-}"
  local new_oid="${hook_args[2]:-}"
  [[ -n "$ref" && -n "$old_oid" && -n "$new_oid" ]] || return 0

  clear_event_env
  export FISHOOK_EVENT_KIND="ref"
  export FISHOOK_REF="$ref"
  export FISHOOK_OLD_OID="$old_oid"
  export FISHOOK_NEW_OID="$new_oid"

  if [[ "$old_oid" =~ ^0+$ ]]; then
    export FISHOOK_EVENT="ref_create"
  elif [[ "$new_oid" =~ ^0+$ ]]; then
    export FISHOOK_EVENT="ref_delete"
  else
    export FISHOOK_EVENT="ref_update"
  fi

  dispatch_event_handlers "$hook" "${hook_args[@]}"
}

# ---- commands ----
do_list() {
  echo "Client-side (patch / email workflows)"
  local h
  for h in applypatch-msg pre-applypatch post-applypatch sendemail-validate; do
    printf "  %-18s %s\n" "$h" "$(hook_explain_text "$h")"
  done
  echo

  echo "Client-side (commit workflow)"
  for h in pre-commit pre-merge-commit prepare-commit-msg commit-msg post-commit; do
    printf "  %-18s %s\n" "$h" "$(hook_explain_text "$h")"
  done
  echo

  echo "Client-side (branch / history changes)"
  for h in pre-rebase post-checkout post-merge post-rewrite; do
    printf "  %-18s %s\n" "$h" "$(hook_explain_text "$h")"
  done
  echo

  echo "Client-side (push / maintenance)"
  for h in pre-push pre-auto-gc; do
    printf "  %-18s %s\n" "$h" "$(hook_explain_text "$h")"
  done
  echo

  echo "Server-side (bare repo / self-hosted only; not GitHub/GitLab.com)"
  for h in pre-receive update post-receive post-update push-to-checkout proc-receive; do
    printf "  %-18s %s\n" "$h" "$(hook_explain_text "$h")"
  done
  echo

  echo "Performance"
  for h in fsmonitor-watchman; do
    printf "  %-18s %s\n" "$h" "$(hook_explain_text "$h")"
  done
}

do_explain() {
  require_jq
  in_git_repo || die "not inside a git repository"

  local -a args=()
  mapfile -d '' -t args < <(parse_flags "$@")

  local hook="${args[0]:-}"
  [[ -n "$hook" ]] || die "usage: $0 explain <hook-name> [--config path] [--hooks-path PATH]"
  hook_known "$hook" || die "unknown hook: $hook"

  [[ -n "$CONFIG_PATH" ]] || CONFIG_PATH="$(default_config_path)"
  [[ -n "$HOOKS_PATH" ]] || HOOKS_PATH="$(default_hooks_path)"

  echo "$hook"
  echo "  $(hook_explain_text "$hook")"

  if [[ ! -f "$CONFIG_PATH" ]]; then
    echo "  fishook.json: (missing) ${CONFIG_PATH}"
    return 0
  fi

  local run_json
  run_json="$(hook_run_cmds_json "$hook")"
  if [[ "$run_json" == "[]" ]]; then
    echo "  configured actions (run): (none)"
  else
    echo "  configured actions (run):"
    printf '%s\n' "$run_json" | jq -r '.[]' | sed 's/^/    - /'
  fi

  local blocks_json
  blocks_json="$(hook_blocks_json "$hook")"
  if [[ "$blocks_json" != "[]" ]]; then
    echo "  configured blocks/handlers:"
    local idx=0
    while IFS= read -r block; do
      idx=$((idx + 1))
      local apply_json skip_json
      apply_json="$(block_apply_to_json "$block")"
      skip_json="$(block_skip_list_json "$block")"
      echo "    block #$idx:"
      if [[ "$apply_json" != "[]" ]]; then
        echo "      applyTo:"
        printf '%s\n' "$apply_json" | jq -r '.[]' | sed 's/^/        - /'
      fi
      if [[ "$skip_json" != "[]" ]]; then
        echo "      skipList:"
        printf '%s\n' "$skip_json" | jq -r '.[]' | sed 's/^/        - /'
      fi
      local keys=(
        onAdd onChange onDelete onMove onCopy onFileEvent
        onRefCreate onRefUpdate onRefDelete onRefEvent
        onEvent
      )
      local any=0 k kjson
      for k in "${keys[@]}"; do
        kjson="$(block_key_cmds_json "$block" "$k")"
        [[ "$kjson" == "[]" ]] && continue
        [[ $any -eq 0 ]] && any=1
        echo "      ${k}:"
        printf '%s\n' "$kjson" | jq -r '.[]' | sed 's/^/        - /'
      done
      [[ $any -eq 0 ]] && echo "      (no handlers)"
    done < <(printf '%s' "$blocks_json" | jq -c '.[]')
  fi
}

do_install() {
  require_jq
  in_git_repo || die "not inside a git repository"

  local -a _ignored=()
  mapfile -d '' -t _ignored < <(parse_flags "$@")

  [[ -n "$HOOKS_PATH" ]] || HOOKS_PATH="$(default_hooks_path)"
  mkdir -p "$HOOKS_PATH"

  [[ -n "$CONFIG_PATH" ]] || CONFIG_PATH="$(default_config_path)"
  write_sample_config "$CONFIG_PATH"

  local hook file prev bak choice
  for hook in "${ALL_HOOKS[@]}"; do
    file="${HOOKS_PATH}/${hook}"

    if [[ ! -e "$file" ]]; then
      write_stub "$hook" "$file"
      continue
    fi

    if is_fishook_stub "$file"; then
      continue
    fi

    choice="$(prompt_choice "$hook" "$file")"
    case "$choice" in
      1)
        bak="${file}.bak.$(timestamp)"
        mv "$file" "$bak"
        write_stub "$hook" "$file"
        ;;
      2)
        prev="${file}.fishook-prev"
        if [[ -e "$prev" ]]; then
          mv "$prev" "${prev}.bak.$(timestamp)"
        fi
        mv "$file" "$prev"
        write_chained_stub "$hook" "$file" "$prev"
        ;;
      3)
        bak="${file}.bak.$(timestamp)"
        mv "$file" "$bak"
        write_stub "$hook" "$file"
        ;;
      *)
        die "invalid choice: $choice"
        ;;
    esac
  done

  echo "fishook: installed stubs into ${HOOKS_PATH}" >&2
}

do_uninstall() {
  in_git_repo || die "not inside a git repository"

  local -a _ignored=()
  mapfile -d '' -t _ignored < <(parse_flags "$@")

  [[ -n "$HOOKS_PATH" ]] || HOOKS_PATH="$(default_hooks_path)"

  local hook file prev
  for hook in "${ALL_HOOKS[@]}"; do
    file="${HOOKS_PATH}/${hook}"
    prev="${file}.fishook-prev"

    if [[ -e "$file" ]] && is_fishook_stub "$file"; then
      rm -f "$file"
      if [[ -e "$prev" ]]; then
        mv "$prev" "$file"
        chmod +x "$file" || true
      fi
    fi
  done

  echo "fishook: uninstalled stubs from ${HOOKS_PATH}" >&2
}

do_run_hook() {
  require_jq
  in_git_repo || die "not inside a git repository"

  local hook="$1"; shift || true
  hook_known "$hook" || die "unknown hook: $hook"

  local -a args=()
  mapfile -d '' -t args < <(parse_flags "$@")
  local -a hook_args=("${args[@]}")

  [[ -n "$CONFIG_PATH" ]] || CONFIG_PATH="$(default_config_path)"
  [[ -n "$HOOKS_PATH" ]] || HOOKS_PATH="$(default_hooks_path)"
  [[ -f "$CONFIG_PATH" ]] || die "config not found: ${CONFIG_PATH}"

  export_base_env "$hook"
  export FISHOOK_ARGS="$(printf '%q ' "${hook_args[@]}" | sed 's/ $//')"

  # Back-compat env
  export GIT_HOOK_KEY="$hook"
  export GIT_HOOK_ARGS="$FISHOOK_ARGS"

  # Step 1: run "run" commands (legacy/simple + block .run concatenation)
  local run_json cmd
  run_json="$(hook_run_cmds_json "$hook")"
  if [[ "$run_json" != "[]" ]]; then
    while IFS= read -r cmd; do
      run_one_cmd "$hook" "$cmd" "${hook_args[@]}"
    done < <(printf '%s' "$run_json" | jq -r '.[]')
  fi

  # Step 2: emit events and run handlers (block-aware). Safe no-op if no handlers present.
  if hook_entry_has_blocks "$hook"; then
    case "$hook" in
      pre-commit)
        emit_pre_commit_file_events "$hook" "${hook_args[@]}"
        ;;
      post-checkout)
        emit_post_checkout_file_events "$hook" "${hook_args[@]}"
        ;;
      post-merge)
        emit_post_merge_file_events "$hook" "${hook_args[@]}"
        ;;
      pre-push)
        emit_ref_events_pre_push "$hook" "${hook_args[@]}"
        ;;
      pre-receive|post-receive)
        emit_ref_events_receive_pack_stdin "$hook" "${hook_args[@]}"
        ;;
      update)
        emit_ref_event_update_args "$hook" "${hook_args[@]}"
        ;;
      *)
        :
        ;;
    esac
  fi
}

print_usage() {
  cat >&2 <<EOF
fishook

Usage:
  $0 install                     [--config /path/to/fishook.json] [--hooks-path PATH]     # install all hooks
  $0 uninstall                   [--hooks-path PATH]                                      # uninstall all hooks
  $0 list                                                                                 # lists all hooks
  $0 explain <hook-name>         [--config /path/to/fishook.json] [--hooks-path PATH]     # explain what the hook does and show configured actions
  $0 <hook-name>  [hook-args...] [--config /path/to/fishook.json] [--dry-run]             # run the hook

fishook.json:
  - Put a fishook.json in your repo (default: <repo-root>/fishook.json)
  - Keys are git hook names (e.g. "pre-commit", "commit-msg")
  - Values are:
      * "string command"
      * ["cmd1", "cmd2", ...]
      * {"run": "cmd"} or {"run": ["cmd1","cmd2"]}  ("commands" also works)
      * or object/array-of-objects with handlers + optional applyTo/skipList

Examples:
  ./fishook.sh install
  ./fishook.sh pre-commit --dry-run
  ./fishook.sh commit-msg .git/COMMIT_EDITMSG
EOF
}

# ---- dispatch ----
CMD="${1:-}"
shift || true

case "${CMD}" in
  ""|help|-h|--help)
    print_usage
    exit 2
    ;;
  install)
    do_install "$@"
    ;;
  uninstall)
    do_uninstall "$@"
    ;;
  list)
    do_list
    ;;
  explain)
    do_explain "$@"
    ;;
  *)
    do_run_hook "$CMD" "$@"
    ;;
esac
