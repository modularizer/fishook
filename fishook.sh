#!/usr/bin/env bash
# fishook.sh
#
# fishook = tiny git hook runner driven by a JSON file.
#
# Usage:
#   $0 install                     [--config /path/to/fishook.json] [--hooks-path PATH]     # install all hooks
#   $0 uninstall                   [--hooks-path PATH]                                      # uninstall all hooks
#   $0 list                                                                                 # lists all hooks
#   $0 explain <hook-name>         [--config /path/to/fishook.json] [--hooks-path PATH]     # explain hook + show configured actions
#   $0 <hook-name>  [hook-args...] [--config /path/to/fishook.json] [--dry-run]             # run the hook
#
# fishook.json:
#   - Put a fishook.json in your repo (default: <repo-root>/fishook.json)
#   - Keys are git hook names (e.g. "pre-commit", "commit-msg")
#   - Values are:
#       * "string command"
#       * ["cmd1", "cmd2", ...]
#       * {"run": "cmd"} or {"run": ["cmd1","cmd2"]}  ("commands" also works)
#       * optional event handlers (for any hook object; best-effort emission):
#           {
#             "run": ["echo runs once"],
#             "onAdd": ["..."], "onChange": ["..."], "onDelete": ["..."],
#             "onMove": ["..."], "onCopy": ["..."],
#             "onFileEvent": ["..."],
#             "onRefCreate": ["..."], "onRefUpdate": ["..."], "onRefDelete": ["..."],
#             "onRefEvent": ["..."],
#             "onEvent": ["..."]
#           }

set -euo pipefail

# ---- hooks list (all standard git hooks) ----
ALL_HOOKS=(
  applypatch-msg pre-applypatch post-applypatch
  pre-commit pre-merge-commit prepare-commit-msg commit-msg post-commit
  pre-rebase post-checkout post-merge post-rewrite
  pre-push pre-auto-gc
  pre-receive update post-receive post-update push-to-checkout proc-receive
  sendemail-validate fsmonitor-watchman
)

# ---- globals set by flag parsing ----
CONFIG_PATH=""
HOOKS_PATH=""
DRY_RUN=0

# ---- helpers ----
die() { echo "fishook: $*" >&2; exit 2; }

in_git_repo() { git rev-parse --is-inside-work-tree >/dev/null 2>&1; }
repo_root() { git rev-parse --show-toplevel 2>/dev/null; }
git_dir() { git rev-parse --git-dir 2>/dev/null; }

default_config_path() {
  local root
  root="$(repo_root)" || die "not inside a git repository"
  echo "${root}/fishook.json"
}

default_hooks_path() {
  local gd
  gd="$(git_dir)" || die "not inside a git repository"
  echo "${gd}/hooks"
}

timestamp() { date +"%Y%m%d-%H%M%S"; }

require_jq() { command -v jq >/dev/null 2>&1 || die "requires 'jq'"; }

# Parse flags anywhere in argv and return remaining positional args on stdout (space-delimited).
# Supports: --config, --hooks-path, --dry-run (plus = forms)
parse_flags() {
  local -a out=()
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --config)
        [[ $# -ge 2 ]] || die "--config requires a path"
        CONFIG_PATH="$2"; shift 2 ;;
      --config=*)
        CONFIG_PATH="${1#*=}"; shift ;;
      --hooks-path)
        [[ $# -ge 2 ]] || die "--hooks-path requires a path"
        HOOKS_PATH="$2"; shift 2 ;;
      --hooks-path=*)
        HOOKS_PATH="${1#*=}"; shift ;;
      --dry-run)
        DRY_RUN=1; shift ;;
      --)
        shift
        while [[ $# -gt 0 ]]; do out+=("$1"); shift; done
        ;;
      -*)
        die "unknown option: $1"
        ;;
      *)
        out+=("$1"); shift ;;
    esac
  done

  # Print as NUL-delimited to be safe; caller should read with mapfile -d ''
  printf '%s\0' "${out[@]}"
}

hook_known() {
  local h="$1"
  local x
  for x in "${ALL_HOOKS[@]}"; do
    [[ "$x" == "$h" ]] && return 0
  done
  return 1
}

# Detect whether a hook file is fishook-managed.
is_fishook_stub() {
  local file="$1"
  [[ -f "$file" ]] || return 1
  grep -qE '^# fishook-managed stub' "$file"
}

# Write a stub that calls fishook.sh <hook>, from repo root.
write_stub() {
  local hook="$1"
  local target="$2"
  cat >"$target" <<EOF
#!/usr/bin/env bash
set -euo pipefail

# fishook-managed stub for ${hook}
# This file is generated by: ./fishook.sh install

REPO_ROOT="\$(git rev-parse --show-toplevel 2>/dev/null)"
if [[ -z "\${REPO_ROOT}" ]]; then
  echo "fishook: cannot find repo root" >&2
  exit 2
fi

exec "\${REPO_ROOT}/fishook.sh" ${hook} "\$@"
EOF
  chmod +x "$target"
}

# For chained hooks, create a stub that runs prev first then fishook.
write_chained_stub() {
  local hook="$1"
  local target="$2"
  local prev="$3"
  cat >"$target" <<EOF
#!/usr/bin/env bash
set -euo pipefail

# fishook-managed stub for ${hook} (chained)
# previous hook preserved at: ${prev}

if [[ -x "${prev}" ]]; then
  "${prev}" "\$@"
fi

REPO_ROOT="\$(git rev-parse --show-toplevel 2>/dev/null)"
if [[ -z "\${REPO_ROOT}" ]]; then
  echo "fishook: cannot find repo root" >&2
  exit 2
fi

exec "\${REPO_ROOT}/fishook.sh" ${hook} "\$@"
EOF
  chmod +x "$target"
}

prompt_choice() {
  local hook="$1"
  local file="$2"
  echo
  echo "fishook: found existing hook: ${file}"
  echo "hook: ${hook}"
  echo
  echo "Choose what to do:"
  echo "  1) overwrite (replace existing hook with fishook)"
  echo "  2) chain (rename existing to ${file}.fishook-prev and run it before fishook)"
  echo "  3) backup (rename existing to ${file}.bak.<timestamp>; not chained)"
  echo -n "Enter 1/2/3: " >&2
  read -r choice
  echo "$choice"
}

# Full sample config (small). Written only if missing.
write_sample_config() {
  local path="$1"
  local dir
  dir="$(dirname "$path")"
  mkdir -p "$dir"

  if [[ -e "$path" ]]; then
    echo "fishook: config already exists, leaving it alone: ${path}" >&2
    return 0
  fi

  cat >"$path" <<'EOF'
{
  "_about": "run `fishook list` to see all options",
  "pre-commit": {
    "run": ["echo pre-commit (once): repo=$FISHOOK_REPO_NAME root=$FISHOOK_REPO_ROOT"],
    "onFileEvent": ["echo file $FISHOOK_EVENT $FISHOOK_PATH"]
  }
}
EOF

  echo "fishook: wrote sample config: ${path}" >&2
}

# Normalize a JSON value into an array of commands.
# - null/missing -> []
# - string       -> [string]
# - array        -> array
# - object       -> (.run // .commands) normalized similarly (used by older format)
normalize_any_to_array() {
  jq -c '
    def normalize:
      if . == null then []
      elif (type == "string") then [.]
      elif (type == "array") then .
      elif (type == "object") then (.run // .commands) | normalize
      else error("hook entry must be string, array, or object")
      end;
    normalize
  '
}

# Normalize the configured entry to a JSON array of commands for a hook (legacy/simple).
# Output: JSON array (possibly empty).
normalized_cmds_json() {
  local hook="$1"
  local config="$2"
  jq -c --arg key "$hook" '
    def normalize:
      if . == null then []
      elif type == "string" then [.]
      elif type == "array" then .
      elif type == "object" then (.run // .commands) | normalize
      else error("invalid hook entry")
      end;
    (.[$key] // null) | normalize
  ' "$config"
}

# Pull a hook's raw JSON entry (or empty).
hook_entry_json() {
  local hook="$1"
  jq -c --arg key "$hook" '(.[$key] // empty)' "$CONFIG_PATH"
}

# Normalize a particular key inside a hook object to an array-of-strings JSON array.
# If hook isn't an object, returns [].
hook_object_key_cmds_json() {
  local hook="$1"
  local key="$2"
  jq -c --arg h "$hook" --arg k "$key" '
    def normalize:
      if . == null then []
      elif type=="string" then [.]
      elif type=="array" then .
      elif type=="object" then (.run // .commands) | normalize
      else error("invalid command value")
      end;

    (.[$h] // null) as $entry
    | if ($entry|type) != "object" then []
      else ($entry[$k] // null) | normalize
      end
  ' "$CONFIG_PATH"
}

# Check whether a hook entry is an object (event-capable).
hook_entry_is_object() {
  local hook="$1"
  jq -e --arg h "$hook" '(.[$h] // null) | (type=="object")' "$CONFIG_PATH" >/dev/null 2>&1
}

# ---- hook explanations (short, useful defaults) ----
hook_explain_text() {
  local h="$1"
  case "$h" in
    applypatch-msg) echo "Runs during git am after extracting a patch commit message; validate/edit the message." ;;
    pre-applypatch) echo "Runs during git am before committing the applied patch; can reject." ;;
    post-applypatch) echo "Runs during git am after committing; notification only." ;;
    pre-commit) echo "Runs before a commit is created; commonly lint/tests/format checks; can reject." ;;
    pre-merge-commit) echo "Runs before creating a merge commit (when merge is clean); can reject." ;;
    prepare-commit-msg) echo "Runs before commit message editor opens; can prefill/edit message." ;;
    commit-msg) echo "Runs after message is written; validate commit message; can reject." ;;
    post-commit) echo "Runs after commit is created; notification only." ;;
    pre-rebase) echo "Runs before rebase starts; can reject." ;;
    post-checkout) echo "Runs after checkout/switch updates working tree; gets old/new HEAD + flag." ;;
    post-merge) echo "Runs after successful merge; often used to refresh deps; gets squash flag." ;;
    post-rewrite) echo "Runs after commit rewriting (amend/rebase); stdin contains old/new oids." ;;
    pre-push) echo "Runs before pushing; stdin lists refs to be updated; can reject." ;;
    pre-auto-gc) echo "Runs before git gc --auto; can abort." ;;
    pre-receive) echo "Server-side: before accepting pushed refs; stdin old/new/ref triples. Not run on GitHub." ;;
    update) echo "Server-side: per-ref update check; args ref/old/new. Not run on GitHub." ;;
    post-receive) echo "Server-side: after refs updated; stdin old/new/ref triples. Not run on GitHub." ;;
    post-update) echo "Server-side: after refs updated; args are ref names. Not run on GitHub." ;;
    push-to-checkout) echo "Server-side: when pushing to checked-out branch with updateInstead. Not run on GitHub." ;;
    proc-receive) echo "Server-side: advanced receive-pack protocol hook. Not run on GitHub." ;;
    sendemail-validate) echo "Runs during git send-email to validate outgoing patch email; can reject." ;;
    fsmonitor-watchman) echo "Used by core.fsmonitor to speed status; reports changed files." ;;
    *) echo "Unknown hook (or not in fishook's known list)." ;;
  esac
}

# ---- env vars ----
export_base_env() {
  local hook="$1"
  local root gd
  root="$(repo_root)" || root=""
  gd="$(git_dir)" || gd=""

  export FISHOOK_HOOK="$hook"
  export FISHOOK_REPO_ROOT="$root"
  export FISHOOK_REPO_NAME="$(basename "$root" 2>/dev/null || echo "")"
  export FISHOOK_GIT_DIR="$gd"
  export FISHOOK_CONFIG_PATH="$CONFIG_PATH"
  export FISHOOK_HOOKS_PATH="$HOOKS_PATH"
  export FISHOOK_DRY_RUN="$DRY_RUN"
  export FISHOOK_CWD="$(pwd)"
  export FISHOOK_ARGV0="$0"
}

clear_event_env() {
  unset FISHOOK_EVENT_KIND FISHOOK_EVENT FISHOOK_STATUS
  unset FISHOOK_PATH FISHOOK_ABS_PATH
  unset FISHOOK_SRC FISHOOK_DST FISHOOK_ABS_SRC FISHOOK_ABS_DST
  unset FISHOOK_REF FISHOOK_OLD_OID FISHOOK_NEW_OID
  unset FISHOOK_REMOTE_NAME FISHOOK_REMOTE_URL
}

abs_in_repo() {
  local rel="$1"
  [[ -z "$FISHOOK_REPO_ROOT" ]] && echo "$rel" && return 0
  echo "${FISHOOK_REPO_ROOT%/}/${rel}"
}

# ---- execution helpers ----
run_one_cmd() {
  local hook="$1"
  local cmd="$2"
  local -a hook_args=("${@:3}")

  echo "[${hook}] \$ ${cmd}" >&2
  [[ "$DRY_RUN" -eq 1 ]] && return 0

  if [[ "${#hook_args[@]}" -gt 0 ]]; then
    local args_quoted
    args_quoted="$(printf '%q ' "${hook_args[@]}" | sed 's/ $//')"
    bash -lc "${cmd} ${args_quoted}"
  else
    bash -lc "${cmd}"
  fi
}

run_cmds_array() {
  local hook="$1"
  local -a cmds=("${@:2}")
  local i=0 total="${#cmds[@]}"
  for cmd in "${cmds[@]}"; do
    i=$((i + 1))
    run_one_cmd "${hook}" "${cmd}"
  done
}

# Load JSON array -> bash array
json_array_to_bash_array() {
  local json="$1"
  mapfile -t _OUT < <(printf '%s' "$json" | jq -r '.[]')
}

# ---- event dispatch (handlers) ----
# Call handlers in order: specific -> kind-generic -> universal
dispatch_event_handlers() {
  local hook="$1"
  local -a hook_args=("${@:2}")

  local specific=""
  local kind_generic=""
  local universal="onEvent"

  if [[ "${FISHOOK_EVENT_KIND:-}" == "file" ]]; then
    kind_generic="onFileEvent"
    case "${FISHOOK_EVENT:-}" in
      add) specific="onAdd" ;;
      change) specific="onChange" ;;
      delete) specific="onDelete" ;;
      move) specific="onMove" ;;
      copy) specific="onCopy" ;;
    esac
  elif [[ "${FISHOOK_EVENT_KIND:-}" == "ref" ]]; then
    kind_generic="onRefEvent"
    case "${FISHOOK_EVENT:-}" in
      ref_create) specific="onRefCreate" ;;
      ref_update) specific="onRefUpdate" ;;
      ref_delete) specific="onRefDelete" ;;
    esac
  fi

  local key
  for key in "$specific" "$kind_generic" "$universal"; do
    [[ -z "$key" ]] && continue
    local cmds_json
    cmds_json="$(hook_object_key_cmds_json "$hook" "$key")"
    [[ "$cmds_json" == "[]" ]] && continue
    mapfile -t CMDS < <(printf '%s' "$cmds_json" | jq -r '.[]')
    for cmd in "${CMDS[@]}"; do
      run_one_cmd "$hook" "$cmd" "${hook_args[@]}"
    done
  done
}

# ---- event emitters ----
emit_file_events_from_name_status_z() {
  local hook="$1"
  shift || true
  local -a hook_args=("$@")

  # input is: status\0path\0  OR  Rxxx\0src\0dst\0, Cxxx\0src\0dst\0
  while IFS= read -r -d '' status; do
    case "$status" in
      A|M|D)
        IFS= read -r -d '' path || true
        clear_event_env
        export FISHOOK_EVENT_KIND="file"
        export FISHOOK_STATUS="$status"
        export FISHOOK_PATH="$path"
        export FISHOOK_ABS_PATH="$(abs_in_repo "$path")"
        case "$status" in
          A) export FISHOOK_EVENT="add" ;;
          M) export FISHOOK_EVENT="change" ;;
          D) export FISHOOK_EVENT="delete" ;;
        esac
        dispatch_event_handlers "$hook" "${hook_args[@]}"
        ;;
      R*|C*)
        IFS= read -r -d '' src || true
        IFS= read -r -d '' dst || true
        clear_event_env
        export FISHOOK_EVENT_KIND="file"
        export FISHOOK_STATUS="$status"
        export FISHOOK_SRC="$src"
        export FISHOOK_DST="$dst"
        export FISHOOK_ABS_SRC="$(abs_in_repo "$src")"
        export FISHOOK_ABS_DST="$(abs_in_repo "$dst")"
        case "$status" in
          R*) export FISHOOK_EVENT="move" ;;
          C*) export FISHOOK_EVENT="copy" ;;
        esac
        dispatch_event_handlers "$hook" "${hook_args[@]}"
        ;;
      *)
        # ignore other statuses
        :
        ;;
    esac
  done
}

emit_pre_commit_file_events() {
  local hook="$1"; shift || true
  local -a hook_args=("$@")
  git diff --cached --name-status -z | emit_file_events_from_name_status_z "$hook" "${hook_args[@]}"
}

emit_diff_tree_file_events() {
  local hook="$1"
  local old="$2"
  local new="$3"
  shift 3 || true
  local -a hook_args=("$@")

  # If old/new are invalid, skip.
  git cat-file -e "${old}^{commit}" >/dev/null 2>&1 || return 0
  git cat-file -e "${new}^{commit}" >/dev/null 2>&1 || return 0

  git diff-tree -r --name-status -z "$old" "$new" | emit_file_events_from_name_status_z "$hook" "${hook_args[@]}"
}

emit_post_checkout_file_events() {
  local hook="$1"; shift || true
  local -a hook_args=("$@")
  # args: old new flag
  local old="${hook_args[0]:-}"
  local new="${hook_args[1]:-}"
  [[ -n "$old" && -n "$new" ]] || return 0
  emit_diff_tree_file_events "$hook" "$old" "$new" "${hook_args[@]}"
}

emit_post_merge_file_events() {
  local hook="$1"; shift || true
  local -a hook_args=("$@")
  # best effort: ORIG_HEAD..HEAD
  local old=""
  old="$(git rev-parse -q --verify ORIG_HEAD 2>/dev/null || true)"
  local new=""
  new="$(git rev-parse -q --verify HEAD 2>/dev/null || true)"
  [[ -n "$old" && -n "$new" ]] || return 0
  emit_diff_tree_file_events "$hook" "$old" "$new" "${hook_args[@]}"
}

emit_ref_events_pre_push() {
  local hook="$1"; shift || true
  local -a hook_args=("$@")
  # args: remote_name remote_url
  local remote_name="${hook_args[0]:-}"
  local remote_url="${hook_args[1]:-}"

  # stdin lines: <local ref> <local oid> <remote ref> <remote oid>
  while read -r local_ref local_oid remote_ref remote_oid; do
    [[ -z "${local_ref:-}" ]] && continue
    clear_event_env
    export FISHOOK_EVENT_KIND="ref"
    export FISHOOK_REMOTE_NAME="$remote_name"
    export FISHOOK_REMOTE_URL="$remote_url"
    export FISHOOK_REF="$remote_ref"
    export FISHOOK_OLD_OID="$remote_oid"
    export FISHOOK_NEW_OID="$local_oid"

    if [[ "${remote_oid:-}" =~ ^0+$ ]]; then
      export FISHOOK_EVENT="ref_create"
    elif [[ "${local_oid:-}" =~ ^0+$ ]]; then
      export FISHOOK_EVENT="ref_delete"
    else
      export FISHOOK_EVENT="ref_update"
    fi

    dispatch_event_handlers "$hook" "${hook_args[@]}"
  done
}

emit_ref_events_receive_pack_stdin() {
  local hook="$1"; shift || true
  local -a hook_args=("$@")
  # stdin lines: <old> <new> <ref>
  while read -r old_oid new_oid ref; do
    [[ -z "${ref:-}" ]] && continue
    clear_event_env
    export FISHOOK_EVENT_KIND="ref"
    export FISHOOK_REF="$ref"
    export FISHOOK_OLD_OID="$old_oid"
    export FISHOOK_NEW_OID="$new_oid"

    if [[ "${old_oid:-}" =~ ^0+$ ]]; then
      export FISHOOK_EVENT="ref_create"
    elif [[ "${new_oid:-}" =~ ^0+$ ]]; then
      export FISHOOK_EVENT="ref_delete"
    else
      export FISHOOK_EVENT="ref_update"
    fi

    dispatch_event_handlers "$hook" "${hook_args[@]}"
  done
}

emit_ref_event_update_args() {
  local hook="$1"; shift || true
  local -a hook_args=("$@")
  # args: ref old new
  local ref="${hook_args[0]:-}"
  local old_oid="${hook_args[1]:-}"
  local new_oid="${hook_args[2]:-}"
  [[ -n "$ref" && -n "$old_oid" && -n "$new_oid" ]] || return 0

  clear_event_env
  export FISHOOK_EVENT_KIND="ref"
  export FISHOOK_REF="$ref"
  export FISHOOK_OLD_OID="$old_oid"
  export FISHOOK_NEW_OID="$new_oid"

  if [[ "$old_oid" =~ ^0+$ ]]; then
    export FISHOOK_EVENT="ref_create"
  elif [[ "$new_oid" =~ ^0+$ ]]; then
    export FISHOOK_EVENT="ref_delete"
  else
    export FISHOOK_EVENT="ref_update"
  fi

  dispatch_event_handlers "$hook" "${hook_args[@]}"
}

# ---- commands ----
do_list() {
  echo "Client-side (patch / email workflows)"
  local h
  for h in applypatch-msg pre-applypatch post-applypatch sendemail-validate; do
    printf "  %-18s %s\n" "$h" "$(hook_explain_text "$h")"
  done
  echo

  echo "Client-side (commit workflow)"
  for h in pre-commit pre-merge-commit prepare-commit-msg commit-msg post-commit; do
    printf "  %-18s %s\n" "$h" "$(hook_explain_text "$h")"
  done
  echo

  echo "Client-side (branch / history changes)"
  for h in pre-rebase post-checkout post-merge post-rewrite; do
    printf "  %-18s %s\n" "$h" "$(hook_explain_text "$h")"
  done
  echo

  echo "Client-side (push / maintenance)"
  for h in pre-push pre-auto-gc; do
    printf "  %-18s %s\n" "$h" "$(hook_explain_text "$h")"
  done
  echo

  echo "Server-side (bare repo / self-hosted only; not GitHub/GitLab.com)"
  for h in pre-receive update post-receive post-update push-to-checkout proc-receive; do
    printf "  %-18s %s\n" "$h" "$(hook_explain_text "$h")"
  done
  echo

  echo "Performance"
  for h in fsmonitor-watchman; do
    printf "  %-18s %s\n" "$h" "$(hook_explain_text "$h")"
  done
}

do_explain() {
  require_jq
  in_git_repo || die "not inside a git repository"

  local -a args=()
  mapfile -d '' -t args < <(parse_flags "$@")

  local hook="${args[0]:-}"
  [[ -n "$hook" ]] || die "usage: $0 explain <hook-name> [--config path] [--hooks-path PATH]"
  hook_known "$hook" || die "unknown hook: $hook"

  [[ -n "$CONFIG_PATH" ]] || CONFIG_PATH="$(default_config_path)"
  [[ -n "$HOOKS_PATH" ]] || HOOKS_PATH="$(default_hooks_path)"

  echo "$hook"
  echo "  $(hook_explain_text "$hook")"

  if [[ ! -f "$CONFIG_PATH" ]]; then
    echo "  fishook.json: (missing) ${CONFIG_PATH}"
    return 0
  fi

  # Show legacy/simple run commands:
  local cmds_json
  cmds_json="$(normalized_cmds_json "$hook" "$CONFIG_PATH")"
  if [[ "$cmds_json" == "[]" ]]; then
    echo "  configured actions: (none)"
  else
    echo "  configured actions (run):"
    printf '%s\n' "$cmds_json" | jq -r '.[]' | sed 's/^/    - /'
  fi

  # If object, show any event handlers present
  if hook_entry_is_object "$hook"; then
    local keys=(
      onAdd onChange onDelete onMove onCopy onFileEvent
      onRefCreate onRefUpdate onRefDelete onRefEvent
      onEvent
    )
    local any=0
    local k
    for k in "${keys[@]}"; do
      local kjson
      kjson="$(hook_object_key_cmds_json "$hook" "$k")"
      [[ "$kjson" == "[]" ]] && continue
      [[ $any -eq 0 ]] && echo "  configured handlers:" && any=1
      echo "    ${k}:"
      printf '%s\n' "$kjson" | jq -r '.[]' | sed 's/^/      - /'
    done
  fi
}

do_install() {
  require_jq
  in_git_repo || die "not inside a git repository"

  local -a _ignored=()
  mapfile -d '' -t _ignored < <(parse_flags "$@")

  [[ -n "$HOOKS_PATH" ]] || HOOKS_PATH="$(default_hooks_path)"
  mkdir -p "$HOOKS_PATH"

  [[ -n "$CONFIG_PATH" ]] || CONFIG_PATH="$(default_config_path)"
  write_sample_config "$CONFIG_PATH"

  local hook file prev bak choice
  for hook in "${ALL_HOOKS[@]}"; do
    file="${HOOKS_PATH}/${hook}"

    if [[ ! -e "$file" ]]; then
      write_stub "$hook" "$file"
      continue
    fi

    if is_fishook_stub "$file"; then
      continue
    fi

    choice="$(prompt_choice "$hook" "$file")"
    case "$choice" in
      1)
        bak="${file}.bak.$(timestamp)"
        mv "$file" "$bak"
        write_stub "$hook" "$file"
        ;;
      2)
        prev="${file}.fishook-prev"
        if [[ -e "$prev" ]]; then
          mv "$prev" "${prev}.bak.$(timestamp)"
        fi
        mv "$file" "$prev"
        write_chained_stub "$hook" "$file" "$prev"
        ;;
      3)
        bak="${file}.bak.$(timestamp)"
        mv "$file" "$bak"
        write_stub "$hook" "$file"
        ;;
      *)
        die "invalid choice: $choice"
        ;;
    esac
  done

  echo "fishook: installed stubs into ${HOOKS_PATH}" >&2
}

do_uninstall() {
  in_git_repo || die "not inside a git repository"

  local -a _ignored=()
  mapfile -d '' -t _ignored < <(parse_flags "$@")

  [[ -n "$HOOKS_PATH" ]] || HOOKS_PATH="$(default_hooks_path)"

  local hook file prev
  for hook in "${ALL_HOOKS[@]}"; do
    file="${HOOKS_PATH}/${hook}"
    prev="${file}.fishook-prev"

    if [[ -e "$file" ]] && is_fishook_stub "$file"; then
      rm -f "$file"
      if [[ -e "$prev" ]]; then
        mv "$prev" "$file"
        chmod +x "$file" || true
      fi
    fi
  done

  echo "fishook: uninstalled stubs from ${HOOKS_PATH}" >&2
}

do_run_hook() {
  require_jq
  in_git_repo || die "not inside a git repository"

  local hook="$1"; shift || true
  hook_known "$hook" || die "unknown hook: $hook"

  local -a args=()
  mapfile -d '' -t args < <(parse_flags "$@")
  local -a hook_args=("${args[@]}")

  [[ -n "$CONFIG_PATH" ]] || CONFIG_PATH="$(default_config_path)"
  [[ -n "$HOOKS_PATH" ]] || HOOKS_PATH="$(default_hooks_path)"
  [[ -f "$CONFIG_PATH" ]] || die "config not found: ${CONFIG_PATH}"

  export_base_env "$hook"
  export FISHOOK_ARGS="$(printf '%q ' "${hook_args[@]}" | sed 's/ $//')"

  # Always set the legacy env too (keep compatibility)
  export GIT_HOOK_KEY="$hook"
  export GIT_HOOK_ARGS="$FISHOOK_ARGS"

  # Step 1: run the legacy/simple "run" commands (string/array/object-run)
  local cmds_json
  cmds_json="$(normalized_cmds_json "$hook" "$CONFIG_PATH")"
  if [[ "$cmds_json" != "[]" ]]; then
    mapfile -t CMDS < <(printf '%s' "$cmds_json" | jq -r '.[]')
    local cmd
    for cmd in "${CMDS[@]}"; do
      run_one_cmd "$hook" "$cmd" "${hook_args[@]}"
    done
  fi

  # Step 2: if this hook entry is an object, try to emit events and run handlers.
  # (If no event handlers are configured, this is still safe/no-op.)
  if hook_entry_is_object "$hook"; then
    case "$hook" in
      pre-commit)
        emit_pre_commit_file_events "$hook" "${hook_args[@]}"
        ;;
      post-checkout)
        emit_post_checkout_file_events "$hook" "${hook_args[@]}"
        ;;
      post-merge)
        emit_post_merge_file_events "$hook" "${hook_args[@]}"
        ;;
      pre-push)
        # pre-push ref updates are on stdin
        emit_ref_events_pre_push "$hook" "${hook_args[@]}"
        ;;
      pre-receive|post-receive)
        emit_ref_events_receive_pack_stdin "$hook" "${hook_args[@]}"
        ;;
      update)
        emit_ref_event_update_args "$hook" "${hook_args[@]}"
        ;;
      *)
        # no well-defined event stream; run-only already handled above
        :
        ;;
    esac
  fi
}

print_usage() {
  cat >&2 <<EOF
fishook

Usage:
  $0 install                     [--config /path/to/fishook.json] [--hooks-path PATH]     # install all hooks
  $0 uninstall                   [--hooks-path PATH]                                      # uninstall all hooks
  $0 list                                                                                 # lists all hooks
  $0 explain <hook-name>         [--config /path/to/fishook.json] [--hooks-path PATH]     # explain what the hook does and show configured actions
  $0 <hook-name>  [hook-args...] [--config /path/to/fishook.json] [--dry-run]             # run the hook

fishook.json:
  - Put a fishook.json in your repo (default: <repo-root>/fishook.json)
  - Keys are git hook names (e.g. "pre-commit", "commit-msg")
  - Values are:
      * "string command"
      * ["cmd1", "cmd2", ...]
      * {"run": "cmd"} or {"run": ["cmd1","cmd2"]}  ("commands" also works)
      * optional event handlers inside any hook object:
          onAdd/onChange/onDelete/onMove/onCopy/onFileEvent
          onRefCreate/onRefUpdate/onRefDelete/onRefEvent
          onEvent

Examples:
  ./fishook.sh install
  ./fishook.sh pre-commit --dry-run
  ./fishook.sh commit-msg .git/COMMIT_EDITMSG

Notes:
  - install/uninstall operate on ALL hooks.
  - if an existing hook is present, you'll be prompted to overwrite/chain/backup.
EOF
}

# ---- dispatch ----
CMD="${1:-}"
shift || true

case "${CMD}" in
  ""|help|-h|--help)
    print_usage
    exit 2
    ;;
  install)
    do_install "$@"
    ;;
  uninstall)
    do_uninstall "$@"
    ;;
  list)
    do_list
    ;;
  explain)
    do_explain "$@"
    ;;
  *)
    do_run_hook "$CMD" "$@"
    ;;
esac
