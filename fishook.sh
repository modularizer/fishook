#!/usr/bin/env bash
# fishook.sh
#
# fishook = tiny git hook runner driven by a JSON file.
#
# Usage:
#   $0 install                     [--config /path/to/fishook.json] [--hooks-path PATH]     # install all hooks
#   $0 uninstall                   [--hooks-path PATH]                                      # uninstall all hooks
#   $0 list                                                                                 # lists all hooks
#   $0 explain <hook-name>         [--config /path/to/fishook.json] [--hooks-path PATH]     # explain hook + show configured actions
#   $0 <hook-name>  [hook-args...] [--config /path/to/fishook.json] [--dry-run]             # run the hook
#
# fishook.json:
#   - Put a fishook.json in your repo (default: <repo-root>/fishook.json)
#   - Keys are git hook names (e.g. "pre-commit", "commit-msg")
#   - Values are:
#       * "string command"
#       * ["cmd1", "cmd2", ...]
#       * {"run": "cmd"} or {"run": ["cmd1","cmd2"]}  ("commands" also works)

set -euo pipefail

# ---- hooks list (all standard git hooks) ----
ALL_HOOKS=(
  applypatch-msg pre-applypatch post-applypatch
  pre-commit pre-merge-commit prepare-commit-msg commit-msg post-commit
  pre-rebase post-checkout post-merge post-rewrite
  pre-push pre-auto-gc
  pre-receive update post-receive post-update push-to-checkout proc-receive
  sendemail-validate fsmonitor-watchman
)

# ---- globals set by flag parsing ----
CONFIG_PATH=""
HOOKS_PATH=""
DRY_RUN=0

# ---- helpers ----
die() { echo "fishook: $*" >&2; exit 2; }

in_git_repo() { git rev-parse --is-inside-work-tree >/dev/null 2>&1; }

repo_root() { git rev-parse --show-toplevel 2>/dev/null; }

git_dir() { git rev-parse --git-dir 2>/dev/null; }

default_config_path() {
  local root
  root="$(repo_root)" || die "not inside a git repository"
  echo "${root}/fishook.json"
}

default_hooks_path() {
  local gd
  gd="$(git_dir)" || die "not inside a git repository"
  echo "${gd}/hooks"
}

timestamp() { date +"%Y%m%d-%H%M%S"; }

require_jq() { command -v jq >/dev/null 2>&1 || die "requires 'jq'"; }

# Parse flags anywhere in argv and return remaining positional args on stdout (space-delimited).
# Supports: --config, --hooks-path, --dry-run (plus = forms)
parse_flags() {
  local -a out=()
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --config)
        [[ $# -ge 2 ]] || die "--config requires a path"
        CONFIG_PATH="$2"; shift 2 ;;
      --config=*)
        CONFIG_PATH="${1#*=}"; shift ;;
      --hooks-path)
        [[ $# -ge 2 ]] || die "--hooks-path requires a path"
        HOOKS_PATH="$2"; shift 2 ;;
      --hooks-path=*)
        HOOKS_PATH="${1#*=}"; shift ;;
      --dry-run)
        DRY_RUN=1; shift ;;
      --)
        shift
        while [[ $# -gt 0 ]]; do out+=("$1"); shift; done
        ;;
      -*)
        die "unknown option: $1"
        ;;
      *)
        out+=("$1"); shift ;;
    esac
  done

  # Print as NUL-delimited to be safe; caller should read with mapfile -d ''
  printf '%s\0' "${out[@]}"
}

hook_known() {
  local h="$1"
  local x
  for x in "${ALL_HOOKS[@]}"; do
    [[ "$x" == "$h" ]] && return 0
  done
  return 1
}

# Detect whether a hook file is fishook-managed.
is_fishook_stub() {
  local file="$1"
  [[ -f "$file" ]] || return 1
  grep -qE '^# fishook-managed stub' "$file"
}

# Write a stub that calls fishook.sh <hook>, from repo root.
write_stub() {
  local hook="$1"
  local target="$2"
  cat >"$target" <<EOF
#!/usr/bin/env bash
set -euo pipefail

# fishook-managed stub for ${hook}
# This file is generated by: ./fishook.sh install

REPO_ROOT="\$(git rev-parse --show-toplevel 2>/dev/null)"
if [[ -z "\${REPO_ROOT}" ]]; then
  echo "fishook: cannot find repo root" >&2
  exit 2
fi

exec "\${REPO_ROOT}/fishook.sh" ${hook} "\$@"
EOF
  chmod +x "$target"
}

# For chained hooks, create a stub that runs prev first then fishook.
write_chained_stub() {
  local hook="$1"
  local target="$2"
  local prev="$3"
  cat >"$target" <<EOF
#!/usr/bin/env bash
set -euo pipefail

# fishook-managed stub for ${hook} (chained)
# previous hook preserved at: ${prev}

if [[ -x "${prev}" ]]; then
  "${prev}" "\$@"
fi

REPO_ROOT="\$(git rev-parse --show-toplevel 2>/dev/null)"
if [[ -z "\${REPO_ROOT}" ]]; then
  echo "fishook: cannot find repo root" >&2
  exit 2
fi

exec "\${REPO_ROOT}/fishook.sh" ${hook} "\$@"
EOF
  chmod +x "$target"
}

prompt_choice() {
  local hook="$1"
  local file="$2"
  echo
  echo "fishook: found existing hook: ${file}"
  echo "hook: ${hook}"
  echo
  echo "Choose what to do:"
  echo "  1) overwrite (replace existing hook with fishook)"
  echo "  2) chain (rename existing to ${file}.fishook-prev and run it before fishook)"
  echo "  3) backup (rename existing to ${file}.bak.<timestamp>; not chained)"
  echo -n "Enter 1/2/3: " >&2
  read -r choice
  echo "$choice"
}

# Full sample config (all hooks). Written only if missing.
write_sample_config() {
  local path="$1"
  local dir
  dir="$(dirname "$path")"
  mkdir -p "$dir"

  if [[ -e "$path" ]]; then
    echo "fishook: config already exists, leaving it alone: ${path}" >&2
    return 0
  fi

  cat >"$path" <<'EOF'
{
  "_about": [
    "fishook.json â€” full reference example (includes every hook)",
    "",
    "Keys are git hook names.",
    "Values may be:",
    "  - string",
    "  - array of strings (run in order)",
    "  - object with { \"run\": ... } (\"commands\" also works)",
    "",
    "Commands run via: bash -lc '<cmd> [hook-args...]'",
    "Env vars available to commands:",
    "  GIT_HOOK_KEY   = hook name",
    "  GIT_HOOK_ARGS  = shell-quoted args passed by git"
  ],

  "applypatch-msg": "echo applypatch-msg: validate patch commit message file=$1",
  "pre-applypatch": "echo pre-applypatch: before applying patch (git am)",
  "post-applypatch": "echo post-applypatch: after applying patch (git am)",

  "pre-commit": ["echo pre-commit: before commit", "echo pre-commit: run lint/tests here"],
  "pre-merge-commit": "echo pre-merge-commit: before merge commit",
  "prepare-commit-msg": "echo prepare-commit-msg: preparing message file=$1 source=$2 extra=$3",
  "commit-msg": "echo commit-msg: validate commit message file=$1",
  "post-commit": "echo post-commit: after commit created",

  "pre-rebase": "echo pre-rebase: before rebase upstream=$1 branch=$2",
  "post-checkout": "echo post-checkout: after checkout old=$1 new=$2 flag=$3",
  "post-merge": "echo post-merge: after merge (squash=$1)",
  "post-rewrite": { "run": ["echo post-rewrite: rewritten by $1", "echo post-rewrite: stdin has old/new oids"] },

  "pre-push": { "run": ["echo pre-push: remote=$1 url=$2", "echo pre-push: stdin has ref updates"] },
  "pre-auto-gc": "echo pre-auto-gc: before git gc --auto",

  "pre-receive": { "run": ["echo pre-receive: server-side (not on GitHub)", "echo pre-receive: stdin old new ref"] },
  "update": "echo update: server-side per-ref ref=$1 old=$2 new=$3 (not on GitHub)",
  "post-receive": { "run": ["echo post-receive: server-side (not on GitHub)", "echo post-receive: stdin old new ref"] },
  "post-update": "echo post-update: server-side refs updated: $@ (not on GitHub)",
  "push-to-checkout": "echo push-to-checkout: server-side update checked-out branch to $1 (not on GitHub)",
  "proc-receive": { "run": ["echo proc-receive: server-side pkt-line protocol (not on GitHub)"] },

  "sendemail-validate": "echo sendemail-validate: validate outgoing email patch body=$1 headers=$2",
  "fsmonitor-watchman": "echo fsmonitor-watchman: fsmonitor hook"
}
EOF

  echo "fishook: wrote sample config: ${path}" >&2
}

# Normalize the configured entry to a JSON array of commands for a hook.
# Output: JSON array (possibly empty).
normalized_cmds_json() {
  local hook="$1"
  local config="$2"
  jq -c --arg key "$hook" '
    def normalize:
      if . == null then []
      elif type == "string" then [.]
      elif type == "array" then .
      elif type == "object" then (.run // .commands) | normalize
      else error("invalid hook entry")
      end;
    (.[$key] // null) | normalize
  ' "$config"
}

# ---- hook explanations (short, useful defaults) ----
hook_explain_text() {
  local h="$1"
  case "$h" in
    applypatch-msg) echo "Runs during git am after extracting a patch commit message; validate/edit the message." ;;
    pre-applypatch) echo "Runs during git am before committing the applied patch; can reject." ;;
    post-applypatch) echo "Runs during git am after committing; notification only." ;;
    pre-commit) echo "Runs before a commit is created; commonly lint/tests/format checks; can reject." ;;
    pre-merge-commit) echo "Runs before creating a merge commit (when merge is clean); can reject." ;;
    prepare-commit-msg) echo "Runs before commit message editor opens; can prefill/edit message." ;;
    commit-msg) echo "Runs after message is written; validate commit message; can reject." ;;
    post-commit) echo "Runs after commit is created; notification only." ;;
    pre-rebase) echo "Runs before rebase starts; can reject." ;;
    post-checkout) echo "Runs after checkout/switch updates working tree; gets old/new HEAD + flag." ;;
    post-merge) echo "Runs after successful merge; often used to refresh deps; gets squash flag." ;;
    post-rewrite) echo "Runs after commit rewriting (amend/rebase); stdin contains old/new oids." ;;
    pre-push) echo "Runs before pushing; stdin lists refs to be updated; can reject." ;;
    pre-auto-gc) echo "Runs before git gc --auto; can abort." ;;
    pre-receive) echo "Server-side: before accepting pushed refs; stdin old/new/ref triples. Not run on GitHub." ;;
    update) echo "Server-side: per-ref update check; args ref/old/new. Not run on GitHub." ;;
    post-receive) echo "Server-side: after refs updated; stdin old/new/ref triples. Not run on GitHub." ;;
    post-update) echo "Server-side: after refs updated; args are ref names. Not run on GitHub." ;;
    push-to-checkout) echo "Server-side: when pushing to checked-out branch with updateInstead. Not run on GitHub." ;;
    proc-receive) echo "Server-side: advanced receive-pack protocol hook. Not run on GitHub." ;;
    sendemail-validate) echo "Runs during git send-email to validate outgoing patch email; can reject." ;;
    fsmonitor-watchman) echo "Used by core.fsmonitor to speed status; reports changed files." ;;
    *) echo "Unknown hook (or not in fishook's known list)." ;;
  esac
}

# ---- commands ----
do_list() {
  local h
  for h in "${ALL_HOOKS[@]}"; do
    echo "$h"
  done
}

do_explain() {
  require_jq
  in_git_repo || die "not inside a git repository"

  # parse flags + args
  local -a args=()
  mapfile -d '' -t args < <(parse_flags "$@")

  local hook="${args[0]:-}"
  [[ -n "$hook" ]] || die "usage: $0 explain <hook-name> [--config path] [--hooks-path PATH]"
  hook_known "$hook" || die "unknown hook: $hook"

  if [[ -z "$CONFIG_PATH" ]]; then
    CONFIG_PATH="$(default_config_path)"
  fi
  if [[ ! -f "$CONFIG_PATH" ]]; then
    echo "fishook.json: (missing) ${CONFIG_PATH}" >&2
  fi

  echo "$hook"
  echo "  $(hook_explain_text "$hook")"

  if [[ -f "$CONFIG_PATH" ]]; then
    local cmds_json
    cmds_json="$(normalized_cmds_json "$hook" "$CONFIG_PATH")"
    if [[ "$cmds_json" == "[]" ]]; then
      echo "  configured actions: (none)"
    else
      echo "  configured actions:"
      # one per line
      printf '%s\n' "$cmds_json" | jq -r '.[]' | sed 's/^/    - /'
    fi
  else
    echo "  configured actions: (cannot load config)"
  fi
}

do_install() {
  require_jq
  in_git_repo || die "not inside a git repository"

  # parse flags (ignore remaining)
  local -a _ignored=()
  mapfile -d '' -t _ignored < <(parse_flags "$@")

  [[ -n "$HOOKS_PATH" ]] || HOOKS_PATH="$(default_hooks_path)"
  mkdir -p "$HOOKS_PATH"

  [[ -n "$CONFIG_PATH" ]] || CONFIG_PATH="$(default_config_path)"
  write_sample_config "$CONFIG_PATH"

  local hook file prev bak choice
  for hook in "${ALL_HOOKS[@]}"; do
    file="${HOOKS_PATH}/${hook}"

    if [[ ! -e "$file" ]]; then
      write_stub "$hook" "$file"
      continue
    fi

    if is_fishook_stub "$file"; then
      continue
    fi

    choice="$(prompt_choice "$hook" "$file")"
    case "$choice" in
      1)
        bak="${file}.bak.$(timestamp)"
        mv "$file" "$bak"
        write_stub "$hook" "$file"
        ;;
      2)
        prev="${file}.fishook-prev"
        if [[ -e "$prev" ]]; then
          mv "$prev" "${prev}.bak.$(timestamp)"
        fi
        mv "$file" "$prev"
        write_chained_stub "$hook" "$file" "$prev"
        ;;
      3)
        bak="${file}.bak.$(timestamp)"
        mv "$file" "$bak"
        write_stub "$hook" "$file"
        ;;
      *)
        die "invalid choice: $choice"
        ;;
    esac
  done

  echo "fishook: installed stubs into ${HOOKS_PATH}" >&2
}

do_uninstall() {
  in_git_repo || die "not inside a git repository"

  # parse flags (ignore remaining)
  local -a _ignored=()
  mapfile -d '' -t _ignored < <(parse_flags "$@")

  [[ -n "$HOOKS_PATH" ]] || HOOKS_PATH="$(default_hooks_path)"

  local hook file prev
  for hook in "${ALL_HOOKS[@]}"; do
    file="${HOOKS_PATH}/${hook}"
    prev="${file}.fishook-prev"

    if [[ -e "$file" ]] && is_fishook_stub "$file"; then
      rm -f "$file"
      if [[ -e "$prev" ]]; then
        mv "$prev" "$file"
        chmod +x "$file" || true
      fi
    fi
  done

  echo "fishook: uninstalled stubs from ${HOOKS_PATH}" >&2
}

do_run_hook() {
  require_jq
  in_git_repo || die "not inside a git repository"

  local hook="$1"; shift || true
  hook_known "$hook" || die "unknown hook: $hook"

  # parse flags anywhere in the remaining args (so you can do: pre-commit --dry-run)
  local -a args=()
  mapfile -d '' -t args < <(parse_flags "$@")
  local -a hook_args=("${args[@]}")

  [[ -n "$CONFIG_PATH" ]] || CONFIG_PATH="$(default_config_path)"
  [[ -f "$CONFIG_PATH" ]] || die "config not found: ${CONFIG_PATH}"

  export GIT_HOOK_KEY="$hook"
  export GIT_HOOK_ARGS="$(printf '%q ' "${hook_args[@]}" | sed 's/ $//')"

  local cmds_json
  cmds_json="$(normalized_cmds_json "$hook" "$CONFIG_PATH")"
  [[ "$cmds_json" == "[]" ]] && exit 0

  local -a cmds=()
  mapfile -t cmds < <(printf '%s' "$cmds_json" | jq -r '.[]')
  [[ "${#cmds[@]}" -eq 0 ]] && exit 0

  local i=0 total="${#cmds[@]}"
  local args_quoted=""
  if [[ "${#hook_args[@]}" -gt 0 ]]; then
    args_quoted="$(printf '%q ' "${hook_args[@]}" | sed 's/ $//')"
  fi

  for cmd in "${cmds[@]}"; do
    i=$((i + 1))
    echo "[${hook}] (${i}/${total}) \$ ${cmd}" >&2

    if [[ "$DRY_RUN" -eq 1 ]]; then
      continue
    fi

    if [[ -n "$args_quoted" ]]; then
      bash -lc "${cmd} ${args_quoted}"
    else
      bash -lc "${cmd}"
    fi
  done
}

print_usage() {
  cat >&2 <<'EOF'
fishook

Usage:
  $0 install                     [--config /path/to/fishook.json] [--hooks-path PATH]     # install all hooks
  $0 uninstall                   [--hooks-path PATH]                                      # uninstall all hooks
  $0 list                                                                                 # lists all hooks
  $0 explain <hook-name>         [--config /path/to/fishook.json] [--hooks-path PATH]     # explain what the hook does and show configured actions
  $0 <hook-name>  [hook-args...] [--config /path/to/fishook.json] [--dry-run]             # run the hook

fishook.json:
  - Put a fishook.json in your repo (default: <repo-root>/fishook.json)
  - Keys are git hook names (e.g. "pre-commit", "commit-msg")
  - Values are:
      * "string command"
      * ["cmd1", "cmd2", ...]
      * {"run": "cmd"} or {"run": ["cmd1","cmd2"]}  ("commands" also works)

Examples:
  ./fishook.sh install
  ./fishook.sh pre-commit --dry-run
  ./fishook.sh commit-msg .git/COMMIT_EDITMSG

Notes:
  - install/uninstall operate on ALL hooks.
  - if an existing hook is present, you'll be prompted to overwrite/chain/backup.
EOF
}

# ---- dispatch ----
CMD="${1:-}"
shift || true

case "${CMD}" in
  ""|help|-h|--help)
    print_usage
    exit 2
    ;;
  install)
    do_install "$@"
    ;;
  uninstall)
    do_uninstall "$@"
    ;;
  list)
    do_list
    ;;
  explain)
    do_explain "$@"
    ;;
  *)
    # Treat as hook name
    do_run_hook "$CMD" "$@"
    ;;
esac
